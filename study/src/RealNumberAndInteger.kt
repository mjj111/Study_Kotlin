/**
 * Byte 1 (Byte 용량) /  (범위) -128 ~ 127
 * Short 2  / -3만 ~ 3만
 * Int 4  / -21억 ~ 21억
 * Long 8  / -922경 ~ 922경
 *
 * Float 4  / 1.410-45  3.40..
 * Double 8 / 1.70736....
 *
 * 실수 타입은 저장 가능 범위가 아니라 소수점 정밀도이다.
 * 컴퓨터는 무한대인 실수를 1.xx형태로 만든다.
 * 표현하려는 수가 2진수로 1011.1001 일 경우, 바로 뒤에 2의 -3승을 곱해 소수점의 위치를 왼쪽으로 3칸 이동시킨다.
 * 그리고 이 값들 중 유효숫자인 10111001와 지수 부분인 -3만을 저장한다.
 * 이와 같은 실수 표현 방식을 부동소수점(Floating Point)라고한다.
 * 소수점이 고정되어있지않고 둥둥떠다니는것 같다.
 *
 * 참고로 코틀린은 8진수 정수 리터럴을 지원하지 않는다.
 * 또한 실수는 정확한 값을 가리키고 있지 않기 때문에 누적으로 10 번이상의 실수 덧셈을 오차가 무시할 수 없을 정도로 누적되어 잘못된 결과가 나온다. 
 */
fun main(args: Array<String>) {
    val a: Byte = 125
    var b: Short = 30000
    var c: Int = 12_4354_6538
    c = 0xFF_88_88
    c = 0b011010_01010_01010101_10110
    var d: Long = -543_7847_3984_7238_4723

    c = a + b
    d = c + 10L

    var e: Float = 67.6f
    val f: Double = 658.456
    e = (e + f).toFloat()
    println(e)
}